{"version":3,"sources":["../source/ReactInput.js"],"names":["React","PropTypes","ReactDOM","_parse","onChange","onCut","onPaste","onKeyDown","ReactInput","storeInstance","instance","input","getInputElement","findDOMNode","event","props","parse","format","onBlur","_event","target","value","undefined","stopPropagation","preventDefault","inputComponent","rest","createElement","ref","isEmpty","text","focus","Component","propTypes","func","isRequired","string","type","defaultProps"],"mappings":"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","file":"ReactInput.js","sourcesContent":["import React from 'react'\nimport PropTypes from 'prop-types'\nimport ReactDOM from 'react-dom'\n\nimport _parse from './parse'\n\nimport\n{\n\tonChange,\n\tonCut,\n\tonPaste,\n\tonKeyDown\n}\nfrom './input control'\n\n// Usage:\n//\n// <ReactInput\n// \tvalue={this.state.phone}\n// \tonChange={phone => this.setState({ phone })}\n// \tparse={character => character}\n// \tformat={value => ({ text: value, template: 'xxxxxxxx' })}/>\n//\nexport default class ReactInput extends React.Component\n{\n\tstatic propTypes =\n\t{\n\t\t// Parses a single characher of `<input/>` text.\n\t\tparse  : PropTypes.func.isRequired,\n\n\t\t// Formats `value` into `<input/>` text.\n\t\tformat : PropTypes.func.isRequired,\n\n\t\t// Renders `<input/>` by default.\n\t\t// For some reason non-default `inputComponent`\n\t\t// will reset caret position.\n\t\tinputComponent : PropTypes.string.isRequired,\n\n\t\t// `<input/>` `type` attribute.\n\t\ttype : PropTypes.string.isRequired,\n\n\t\t// Is parsed from <input/> text.\n\t\tvalue  : PropTypes.string,\n\n\t\t// This handler is called each time `<input/>` text is changed.\n\t\tonChange : PropTypes.func.isRequired,\n\n\t\t// This `onBlur` interceptor is a workaround for `redux-form`,\n\t\t// so that it gets the parsed `value` in its `onBlur` handler,\n\t\t// not the formatted text.\n\t\tonBlur : PropTypes.func,\n\n\t\t// Passthrough\n\t\tonKeyDown : PropTypes.func\n\t}\n\n\tstatic defaultProps =\n\t{\n\t\t// Renders `<input/>` by default.\n\t\t// For some reason non-default `inputComponent`\n\t\t// will reset caret position.\n\t\tinputComponent : 'input',\n\n\t\t// `<input/>` `type` attribute.\n\t\ttype : 'text'\n\t}\n\n\trender()\n\t{\n\t\tconst\n\t\t{\n\t\t\tvalue,\n\t\t\tparse,\n\t\t\tformat,\n\t\t\tinputComponent,\n\t\t\t...rest\n\t\t}\n\t\t= this.props\n\n\t\t// Non-string `inputComponent`s would work in this case\n\t\t// but it would also introduce a caret reset bug:\n\t\t// the caret position would reset on each input.\n\t\t// The origins of this bug are unknown, they may be\n\t\t// somehow related to the `ref` property\n\t\t// being intercepted by React here.\n\t\treturn React.createElement(inputComponent,\n\t\t{\n\t\t\t...rest,\n\t\t\tref       : this.storeInstance,\n\t\t\tvalue     : format(isEmpty(value) ? '' : value).text,\n\t\t\tonKeyDown : this.onKeyDown,\n\t\t\tonChange  : this.onChange,\n\t\t\tonPaste   : this.onPaste,\n\t\t\tonCut     : this.onCut,\n\t\t\tonBlur    : this.onBlur\n\t\t})\n\t}\n\n\tstoreInstance = (instance) =>\n\t{\n\t\tthis.input = instance\n\t}\n\n\t/**\n\t * Returns `<input/>` DOM Element.\n\t * @return {DOMElement}\n\t */\n\tgetInputElement = () =>\n\t{\n\t\treturn ReactDOM.findDOMNode(this.input)\n\t}\n\n\tonChange = (event) =>\n\t{\n\t\tconst\n\t\t{\n\t\t\tparse,\n\t\t\tformat\n\t\t}\n\t\t= this.props\n\n\t\treturn onChange\n\t\t(\n\t\t\tevent,\n\t\t\tthis.getInputElement(),\n\t\t\tparse,\n\t\t\tformat,\n\t\t\tthis.props.onChange\n\t\t)\n\t}\n\n\tonPaste = () =>\n\t{\n\t\tconst\n\t\t{\n\t\t\tparse,\n\t\t\tformat\n\t\t}\n\t\t= this.props\n\n\t\treturn onPaste\n\t\t(\n\t\t\tevent,\n\t\t\tthis.getInputElement(),\n\t\t\tparse,\n\t\t\tformat,\n\t\t\tthis.props.onChange\n\t\t)\n\t}\n\n\tonCut = () =>\n\t{\n\t\tconst\n\t\t{\n\t\t\tparse,\n\t\t\tformat\n\t\t}\n\t\t= this.props\n\n\t\treturn onCut\n\t\t(\n\t\t\tevent,\n\t\t\tthis.getInputElement(),\n\t\t\tparse,\n\t\t\tformat,\n\t\t\tthis.props.onChange\n\t\t)\n\t}\n\n\t// This handler is a workaround for `redux-form`.\n\tonBlur = (event) =>\n\t{\n\t\tconst { parse, onBlur } = this.props\n\n\t\t// This `onBlur` interceptor is a workaround for `redux-form`,\n\t\t// so that it gets the right (parsed, not the formatted one)\n\t\t// `event.target.value` in its `onBlur` handler.\n\t\tif (onBlur)\n\t\t{\n\t\t\tconst _event =\n\t\t\t{\n\t\t\t\t...event,\n\t\t\t\ttarget:\n\t\t\t\t{\n\t\t\t\t\t...event.target,\n\t\t\t\t\tvalue: _parse(this.getInputElement().value, undefined, parse).value\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For `redux-form` event detection.\n\t\t\t// https://github.com/erikras/redux-form/blob/v5/src/events/isEvent.js\n\t\t\t_event.stopPropagation = event.stopPropagation\n\t\t\t_event.preventDefault  = event.preventDefault\n\n\t\t\tonBlur(_event)\n\t\t}\n\t}\n\n\tonKeyDown = (event) =>\n\t{\n\t\tconst\n\t\t{\n\t\t\tparse,\n\t\t\tformat\n\t\t}\n\t\t= this.props\n\n\t\tif (this.props.onKeyDown)\n\t\t{\n\t\t\tthis.props.onKeyDown(event)\n\t\t}\n\n\t\treturn onKeyDown\n\t\t(\n\t\t\tevent,\n\t\t\tthis.getInputElement(),\n\t\t\tparse,\n\t\t\tformat,\n\t\t\tthis.props.onChange\n\t\t)\n\t}\n\n\t/**\n\t * Focuses the `<input/>`.\n\t * Can be called manually.\n\t */\n\tfocus()\n\t{\n\t\tthis.getInputElement().focus()\n\t}\n}\n\nfunction isEmpty(value)\n{\n\treturn value === undefined || value === null\n}"]}