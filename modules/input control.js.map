{"version":3,"sources":["../source/input control.js"],"names":["edit","parse","format","getOperation","getSelection","getCaretPosition","setCaretPosition","onCut","event","input","_parse","_format","on_change","setTimeout","format_input_text","undefined","onPaste","selection","erase_selection","onChange","onKeyDown","operation","preventDefault","text","value","slice","start","end","caret","operation_applied","formatted"],"mappings":"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","file":"input control.js","sourcesContent":["import edit   from './edit'\nimport parse  from './parse'\nimport format from './format'\n\nimport\n{\n\tgetOperation,\n\tgetSelection,\n\tgetCaretPosition,\n\tsetCaretPosition\n}\nfrom './dom'\n\nexport function onCut(event, input, _parse, _format, on_change)\n{\n\t// The actual cut hasn't happened just yet hence the timeout.\n\tsetTimeout(() => format_input_text(input, _parse, _format, undefined, on_change), 0)\n}\n\nexport function onPaste(event, input, _parse, _format, on_change)\n{\n\tconst selection = getSelection(input)\n\n\t// If selection is made,\n\t// just erase the selected text\n\t// prior to pasting\n\tif (selection)\n\t{\n\t\terase_selection(input, selection)\n\t}\n\n\tformat_input_text(input, _parse, _format, undefined, on_change)\n}\n\nexport function onChange(event, input, _parse, _format, on_change)\n{\n\tformat_input_text(input, _parse, _format, undefined, on_change)\n}\n\n// Intercepts \"Delete\" and \"Backspace\" keys.\n// (hitting \"Delete\" or \"Backspace\" at any caret\n//  position should always result in rasing a digit)\nexport function onKeyDown(event, input, _parse, _format, on_change)\n{\n\tconst operation = getOperation(event)\n\n\tswitch (operation)\n\t{\n\t\tcase 'Delete':\n\t\tcase 'Backspace':\n\t\t\t// Intercept this operation and perform it manually.\n\t\t\tevent.preventDefault()\n\n\t\t\tconst selection = getSelection(input)\n\n\t\t\t// If selection is made,\n\t\t\t// just erase the selected text,\n\t\t\t// and don't apply any more operations to it.\n\t\t\tif (selection)\n\t\t\t{\n\t\t\t\terase_selection(input, selection)\n\t\t\t\treturn format_input_text(input, _parse, _format, undefined, on_change)\n\t\t\t}\n\n\t\t\t// Else, perform the (character erasing) operation manually\n\t\t\treturn format_input_text(input, _parse, _format, operation, on_change)\n\n\t\tdefault:\n\t\t\t// Will be handled when `onChange` fires.\n\t}\n}\n\n/**\n * Erases the selected text inside an `<input/>`.\n * @param  {DOMElement} input\n * @param  {Selection} selection\n */\nfunction erase_selection(input, selection)\n{\n\tlet text = input.value\n\ttext = text.slice(0, selection.start) + text.slice(selection.end)\n\n\tinput.value = text\n\tsetCaretPosition(input, selection.start)\n}\n\n/**\n * Parses and re-formats `<input/>` textual value.\n * E.g. when a user enters something into the `<input/>`\n * that raw input must first be parsed and the re-formatted properly.\n * Is called either after some user input (e.g. entered a character, pasted something)\n * or after the user performed an `operation` (e.g. \"Backspace\", \"Delete\").\n * @param  {DOMElement} input\n * @param  {Function} parse\n * @param  {Function} format\n * @param  {string} [operation] - The operation that triggered `<input/>` textual value change. E.g. \"Backspace\", \"Delete\".\n * @param  {Function} onChange\n */\nfunction format_input_text(input, _parse, _format, operation, on_change)\n{\n\t// Parse `<input/>` textual value.\n\t// Get `value` and `caret` position.\n\tlet { value, caret } = parse(input.value, getCaretPosition(input), _parse)\n\n\t// If a user performed an operation (e.g. \"Backspace\", \"Delete\")\n\t// then apply that operation and get new `value` and `caret` position.\n\tif (operation)\n\t{\n\t\tconst operation_applied = edit(value, caret, operation)\n\n\t\tvalue = operation_applied.value\n\t\tcaret = operation_applied.caret\n\t}\n\n\t// Format the `value`.\n\t// (and reposition the caret accordingly)\n\tconst formatted = format(value, caret, _format)\n\n\tconst text = formatted.text\n\tcaret      = formatted.caret\n\n\t// Set `<input/>` textual value manually\n\t// to prevent React from resetting the caret position\n\t// later inside subsequent `render()`.\n\t// Doesn't work for custom `inputComponent`s for some reason.\n\tinput.value = text\n\t// Position the caret properly.\n\tsetCaretPosition(input, caret)\n\n\t// `<input/>` textual value may have changed,\n\t// so the parsed `value` may have changed too.\n\t// The `value` didn't neccessarily change\n\t// but it might have.\n\ton_change(value)\n}"]}